{"version":3,"sources":["edge.ts","shear.js.ts"],"names":[],"mappings":"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","file":"shear.map","sourceRoot":"../src","sourcesContent":["function getTextNodes(root: Node) {\n    let list: Text[] = [];\n    if (root.nodeType === Node.TEXT_NODE) list.push(root as Text);\n    [].slice.call(root.childNodes).map(n => {\n        list = list.concat(getTextNodes(n));\n    });\n    return list;\n}\n\nfunction getPos(targetNode: Node, lineClamp: number) {\n    const range = document.createRange();\n    const texts = getTextNodes(targetNode);\n    let lastHeight: number = null;\n    let changeTimes = 0;\n    range.setStart(texts[0], 0);\n    (() => {\n        for (let i = 0; i < texts.length; i++) {\n            for (let j = 0; j < texts[i].length; j++) {\n                range.setEnd(texts[i], j);\n                const height = range.getBoundingClientRect().height;\n                if (height !== lastHeight) {\n                    changeTimes++;\n                    lastHeight = height;\n                }\n                if (changeTimes > lineClamp) {\n                    range.setStart(texts[i], j);\n                    range.setEnd(texts[i], j);\n                    return;\n                }\n            }\n        }\n    })();\n    return range;\n}\n\nexport default getPos;\nexport { getTextNodes };\n","import getPos, { getTextNodes } from \"./edge\";\n\nconst isMicrosoft = !(\"modify\" in window.getSelection());\n\nfunction createFrag(htmlString: string) {\n    const div = document.createElement(\"div\");\n    div.innerHTML = htmlString.trim();\n    return div.firstChild;\n}\n\nfunction shear(targetNode: Element, lineClamp = 2, afterHTML: string = null) {\n    if (!targetNode.childNodes.length)\n        return {\n            isCuted: false,\n            fullHTML: \"\",\n            cutedHTML: \"\",\n            cutedWithAfterHTML: \"\",\n        };\n\n    const selection = window.getSelection();\n    const fullHTML = targetNode.innerHTML;\n    const fullHeight = targetNode.getBoundingClientRect().height;\n\n    // 把选区折叠到目标节点起始处\n    selection.collapse(targetNode, 0);\n\n    let divideCaret: Range;\n\n    if (isMicrosoft) {\n        divideCaret = getPos(targetNode, lineClamp);\n    } else {\n        // 选N行\n        for (let i = 0; i < lineClamp; i++) {\n            (selection as any).modify(\"extend\", \"right\", \"character\");\n            (selection as any).modify(\"extend\", \"right\", \"lineboundary\");\n            // 如果选区终点已经超出了目标节点，说明N行的内容包含整个目标节点，\n            // 就不再进行行选中\n            if (!targetNode.contains(selection.focusNode)) {\n                selection.selectAllChildren(targetNode);\n                break;\n            }\n        }\n        selection.collapseToEnd();\n        divideCaret = selection.getRangeAt(0).cloneRange();\n    }\n\n    // 将选区设置为未被前一步选中的内容，直接进行删除。\n    selection.selectAllChildren(targetNode);\n    divideCaret.setEnd(\n        selection.getRangeAt(0).endContainer,\n        selection.getRangeAt(0).endOffset,\n    );\n    selection.removeAllRanges();\n    divideCaret.cloneRange().deleteContents();\n\n    const cutedHTML = targetNode.innerHTML;\n    const isCuted = fullHTML !== cutedHTML;\n    let cutedWithAfterHTML = cutedHTML;\n\n    // 插入afterHTML\n    const truncatedHeight = targetNode.getBoundingClientRect().height;\n    if (truncatedHeight < fullHeight && afterHTML) {\n        const frag = createFrag(afterHTML);\n\n        // 将选区定位到目标元素结尾\n        let texts = getTextNodes(targetNode);\n        const endText = texts[texts.length - 1];\n        const endOffset = endText.length;\n        const insertCaret = document.createRange();\n        insertCaret.setStart(endText, endOffset);\n        insertCaret.setEnd(endText, endOffset);\n\n        // 插入html fragment\n        insertCaret.insertNode(frag);\n\n        // 从插入处向左删除字符，直到目标节点高度恢复到插入afterHTML前为止\n        (() => {\n            for (let i = texts.length - 1; i >= 0; i--) {\n                for (let j = texts[i].length - 1; j >= 0; j--) {\n                    const curHeight = targetNode.getBoundingClientRect().height;\n                    if (curHeight <= truncatedHeight) return;\n\n                    const delRange = document.createRange();\n                    delRange.setStart(texts[i], j);\n                    delRange.setEnd(texts[i], j + 1);\n                    delRange.deleteContents();\n                }\n            }\n        })();\n        cutedWithAfterHTML = targetNode.innerHTML;\n    }\n\n    selection.removeAllRanges();\n    return { isCuted, fullHTML, cutedHTML, cutedWithAfterHTML };\n}\n\nexport default shear;\n"]}